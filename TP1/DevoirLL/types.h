#include "listeschainees.h"

union value {
  int n;
  char name[4];
};

typedef struct {
  char type; //0 si entier, 1 si numéro de registre, 2 si adr absolue, 3 si adr relative
  char intorname; //0 si value est un entier, 1 sinon
  union value val;  //soit un entier, soit un nom (reference ou definition)
} arginstr;

typedef struct {
  char *def;
  char *name;
  char nbarg; //nombre d'arguments (1 ou 2)
  arginstr *args;
} instr;

typedef struct {
  int size; // en nombre d'instructions
  instr *listeinstr;
} module;

void affichemem(int memsize, instr *mem);
// affichage dans le terminal d'une liste d'instruction, e.g. la ram, la premiere colonne donne la representation memoire utilisee ici, la seconde est de type langage d'assemblage

arginstr newarg (char type, char intorname, union value val);
//creation d'un element de type argument d'une instruction

instr newinstr (char * def,char *name,char nbarg, char type0, char intorname0, union value val0, char type1, char intorname1, union value val1);
//creation d'un element de type instruction

module newmod (int size,instr *listeinstr);
  //creation d'un element de type module

int loader(int debut, module mod, instr *mem);
// loader prend comme arguments la position de chargement en ram, le tableau des modules à charger et la liste des emplacements memoires, il retourne la premiere position qui suit les modules charges

module linker(int nbmods, module *mods, List *table);
//linker rassemble les modules en mettant les adresses en coherence : les adresses du second module sont decalees de la taille du premier, etc...
//linker remplit la table des symboles passee en arguments avec :
//-les refs de tous les modules : nom sans adresse
//-les defs de tous les modules : nom et adresse
//puis fait la resolution en parcourant tous les arguments de toutes les instructions pour remplacer les refs par les adresses obtenues dans la table des symboles
//le module construit est retourné par la fonction
