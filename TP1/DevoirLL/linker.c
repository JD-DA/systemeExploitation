#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "types.h"

module linker(int nbmods, module *mods, List *table) {
  int pos = 0;
  int nbinstr = 0;
  for(int i=0; i<nbmods;i++){
      nbinstr+=mods[i].size;
  }
  instr *linstr = (instr *)malloc(nbinstr * sizeof(instr));
  module mod = newmod(nbinstr,linstr);
  
  //passe 1, créer un module unique pour les regrouper tous en décalant les adresses relatives dans chaque module
  int addr=0;
    for(int i=0; i<nbmods;i++){
        instr* instr1 = mods[i].listeinstr;
        for(int j=0; j<mods[i].size;j++){
            linstr[addr]=instr1[j];
            addr++;
        }
    }
  //passe 2, remplir la table des symboles

  for(int i=0; i<nbinstr;i++){
      instr instr1 = linstr[i];
      //ceci est la partie problematique oon ajoute dans la liste depuis un union
      // alors on place dans la liste chainée une ref vers le name de union depuis une reference d'instruction
      // or plus tard cette reference d'instruction va etre remplacée par une adrese relative du coup
      // le pointeur du name de la liste est alors corrompu
      /*for(int n=0;n<instr1.nbarg;n++){
          if (instr1.args[n].type==3 && instr1.args[n].intorname==1){ // && intorstring = 1
              char *nom="tes";
              strcpy(instr1.args[n].val.name,nom);
              //ajoutReference(table,nom);
          }
      }*/
      if(strcmp(instr1.def,"")!=0) {
          ajoutDefinition(table, instr1.def, i);
      }
  }

  //passe 3, remplacer pour chaque référence le nom par l'adresse de la définition
    for(int i=0; i<nbinstr;i++){
        instr instr1 = linstr[i];
        for(int n=0;n<instr1.nbarg;n++){
            if (instr1.args[n].type==3 && instr1.args[n].intorname==1){ // && intorstring = 1
                instr1.args[n].intorname=0;
// c'est là que la liste est modifiée...
                instr1.args[n].val.n=checkRef(table,instr1.args[n].val.name);

            }
        }
    }

  return mod;
}
